---
layout: presentation
year: 2014
---
<section>
	<h1>Testing</h1>
	<h3>Instructors</h3>
	<p>Carl, Jonathon</p>
</section>
<section>
	<h2>How Do You Test Code?</h2>
	<p>ask students what they think testing means.
	is there a difference between testing, debugging, fixing compiler warnings?
	What do these things have to do with error handling?</p>
	<p>compiler - only about syntax, not about ``universe'' program represents</p>
	<p>debugging - about finding out what's breaking where when you know something is wrong</p>
	<p>testing - expressing program ``universe'' + checking for compliance with its rules</p>
</section>
<section>
	<h2>What Can Testing Do For You?</h2>
	<p>fundamentally not about proving software works, but rather finding that it doesn't work
	for conditions people care about.
	</p>
</section>
<section>
	<h2>Python Unit Testing Syntax</h2>
	<p>unittest, unittest.mock</p>
</section>
<section>
	<h2>When / How To Test</h2>
	<p>value of writing them during development</p>
	<p>value of writing them while debugging</p>
	<p>running them as part of changing software, changing environment</p>
	<p>testing is fundamentally about confidence: enough verification that product works the way the idealization
		in your head does?
	</p>
</section>
<section>
	<h2>Other Kinds of Testing</h2>
	<p>design-by-contract</p>
	<p>performance -
	verify not doing something silly algorithmically, that bench work will translate into real world</p>
	<p>error handling - that expected technical failures (IO errors, garbage in) handled gracefully</p>
	<p>stochastic - for simulations, verifying expected distributions</p>
	<p>non-automated varieties - write down what you expect to observe, try the software and see; looks a lot like
		debugging, but more exploratory than forensic
	</p>
</section>
<section>
	<h2>Extra Items</h2>
	<p>coverage?</p>
</section>
