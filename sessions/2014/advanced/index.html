---
layout: presentation
year: 2014
---
<section>
	<h1>STDIO Ghana</h1>
	<h3><i>a course on</i></h3>
	<h3>Software Engineering</h3>
	<p>supported by ONR Global, Univ. of Ghana, Univ. of Florida, Penn. State. Univ., US Naval Academy</p>
</section>
<section>
	<h1>Python advanced</h1>
</section>
<section>
	<h2>Instructors</h2>
	<dl>
		<dt>Seifu Chonde</dt><dd>PhD Candidate, Industrial Engineering and Operations Research, Penn State University</dd>
		<dt>Deanne McPherson</dt><dd>PhD Candidate, Industrial Engineering and Operations Research, Penn State University</dd>

	</dl>
</section>
<section>
	<h3>Python Basics Recap</h3>
<p>
1.	Make a list of three employees named &quot;bob&quot;, &quot;sue&quot;,  and &quot;rick&quot;
2.	Make a dictionary of three employees named &quot;bob&quot;, &quot;sue&quot;,  and &quot;rick&quot; that have a position [waiter, host, cook] and a salary [3, 4, 8].
3.	Using the dictionary from above, raise the employees&#39; salaries by 10%.
4.	Write a function that will output every employees information.
</p>
</section>
<section>
	<h3>Variable Scope</h3>
	{% highlight py %}
	class BankAccount(object):
	    def __init__(self, initial_balance=0):
	        self.balance = initial_balance
	    def deposit(self, amount):
 	       self.balance += amount
 	   def withdraw(self, amount):
 	       self.balance -= amount
  	  def overdrawn(self):
    	    return self.balance < 0
	my_account = BankAccount(15)
	my_account.withdraw(5)
	print my_account.balance
	{% endhighlight %}
</section>
<section>
	<h3>Exception Handling</h3>
	<ul>
		<li>try, except, else</li>
		<li>try, except, else, finally</li>
	</ul>

	<aside class ="notes">
	An exception is an event, which occurs during the execution of a program that disrupts the normal flow of the program’s instructions. When you are uncertain if your code will raise an exception you can defend your program by placing the suspicious code in a try: block. After the try: block, include an except: statement, followed by a block of code which handles the problem as elegantly as possible.
	</aside>
</section>


<section>

	{% highlight py %}
	try:
		You do your operations here
	except ExceptionI:
		IF there is ExceptionI, then execute this block
	except ExceptionII:
		IF there is ExceptionII, then execute this block
	else:
		IF there is no exception then execute this block
	{% endhighlight %}
</section>
<section>

	{% highlight py %}
	try:
		fh = open("testfile", "w")
		fh.write("this is my test file for exception handling")
	except IOError:
		print "Error: can\'t find file or read data"
	else:
		print "Written content in the file successfully"
		fh.close()
	{% endhighlight %}
</section>
<section>

	{% highlight py %}
	try:
		You do your operations here
		If an exception occurs you skip remaining code
	finally:
		This is always exectued
	{% endhighlight %}
</section>

<section>

	<h5>Problem:</h5>
<p>Write a script that sets a variable to any string. Next write a try and except block to convert the string to an integer using the in() function or print that &quot;The argument does not contain numbers&#92n&quot;</p>
</section>

<section>
	<h3>Comprehensions</h3>
Concise way to create lists.
	{% highlight py %}
	mylist = [expression(i) for i in old_list if filter(i)]	
	{% endhighlight %}
</section>

<section>
	{% highlight py %}
	# You can either use loops:
squares = []

for x in range(10):
    squares.append(x**2)


# Or you can use list comprehensions to get the same result:
squares2 = [x**2 for x in range(10)]
	
	{% endhighlight %}
</section>

<section>
	{% highlight py %}
	 [x+y for x in [10,30,50] for y in [20,40,60]]
	 [30, 50, 70, 50, 70, 90, 70, 90, 110]	
	{% endhighlight %}
</section>

<section>
	
	<h5>Creating Classes</h5>
	<p>The <i>class</i> syntax will create a new class. The name of the class is preceeded immediately by the keyword class</p>
	{% highlight py %}
	class ClassName:
		#Optional class documentation string
		class_suite	
	{% endhighlight %}
	
</section>
<section>
	<h3>Methods and Functions</h3>
</section>
<section>
	<h3>Object Mutabilitiy</h3>
	<p>
		Objects are either <i>mutable</i> or <i>immutable</i>. An immutable object will not allow changes to it after it is created. Examples of immutable objects are numbers, booleans, strings, tuples, and frozensets.
	</p>
</section>
<section>
	<h3>Class Mutability</h3>
	<p>Classes are mutable in general. To mimic immutability you can do something like this:</p>
	{% highlight py %}
	class Immutable(object):
     		"""An immutable class with a single attribute 'value'."""
     		def __setattr__(self, *args):
         		raise TypeError("can't modify immutable instance")
		 __delattr__ = __setattr__
     		def __init__(self, value):
         		# we can no longer use self.value = value to store the instance data
         		# so we must explicitly call the superclass
         		super(Immutable, self).__setattr__('value', value)
         {% endhighlight %}
</section>

<section>
	<h5>Mutability Exercise</h5>
</section>

<section>
	<h3>Optional/Deafult Arguments in Functions</h3>
</section>
<section>
	<h5>Arguments Example 1</h5>
</section>
<section>
	<h3>Variable-length Arguments</h3>
</section>
<section>
	<h5>Arguments Example 2</h5>
</section>
<section>
	<h3>Anonymous Functions and Uses</h3>
</section>
<section>
	<h5>Functions Examples</h5>
</section>


